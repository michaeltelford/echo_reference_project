//golint:ignore
// generated by "charlatan Database SQLResult".  DO NOT EDIT.

package api

import "database/sql"
import "reflect"

// DatabaseExecInvocation represents a single call of FakeDatabase.Exec
type DatabaseExecInvocation struct {
	Parameters struct {
		Query string
		Args  []interface{}
	}
	Results struct {
		Ident1 sql.Result
		Ident2 error
	}
}

// NewDatabaseExecInvocation creates a new instance of DatabaseExecInvocation
func NewDatabaseExecInvocation(query string, args []interface{}, ident1 sql.Result, ident2 error) *DatabaseExecInvocation {
	invocation := new(DatabaseExecInvocation)

	invocation.Parameters.Query = query
	invocation.Parameters.Args = args

	invocation.Results.Ident1 = ident1
	invocation.Results.Ident2 = ident2

	return invocation
}

// DatabaseGetInvocation represents a single call of FakeDatabase.Get
type DatabaseGetInvocation struct {
	Parameters struct {
		Dest  interface{}
		Query string
		Args  []interface{}
	}
	Results struct {
		Ident1 error
	}
}

// NewDatabaseGetInvocation creates a new instance of DatabaseGetInvocation
func NewDatabaseGetInvocation(dest interface{}, query string, args []interface{}, ident1 error) *DatabaseGetInvocation {
	invocation := new(DatabaseGetInvocation)

	invocation.Parameters.Dest = dest
	invocation.Parameters.Query = query
	invocation.Parameters.Args = args

	invocation.Results.Ident1 = ident1

	return invocation
}

// DatabaseSelectInvocation represents a single call of FakeDatabase.Select
type DatabaseSelectInvocation struct {
	Parameters struct {
		Dest  interface{}
		Query string
		Args  []interface{}
	}
	Results struct {
		Ident1 error
	}
}

// NewDatabaseSelectInvocation creates a new instance of DatabaseSelectInvocation
func NewDatabaseSelectInvocation(dest interface{}, query string, args []interface{}, ident1 error) *DatabaseSelectInvocation {
	invocation := new(DatabaseSelectInvocation)

	invocation.Parameters.Dest = dest
	invocation.Parameters.Query = query
	invocation.Parameters.Args = args

	invocation.Results.Ident1 = ident1

	return invocation
}

// DatabaseTestingT represents the methods of "testing".T used by charlatan Fakes.  It avoids importing the testing package.
type DatabaseTestingT interface {
	Error(...interface{})
	Errorf(string, ...interface{})
	Fatal(...interface{})
	Helper()
}

/*
FakeDatabase is a mock implementation of Database for testing.
Use it in your tests as in this example:

	package example

	func TestWithDatabase(t *testing.T) {
		f := &api.FakeDatabase{
			ExecHook: func(query string, args ...interface{}) (ident1 sql.Result, ident2 error) {
				// ensure parameters meet expections, signal errors using t, etc
				return
			},
		}

		// test code goes here ...

		// assert state of FakeExec ...
		f.AssertExecCalledOnce(t)
	}

Create anonymous function implementations for only those interface methods that
should be called in the code under test.  This will force a panic if any
unexpected calls are made to FakeExec.
*/
type FakeDatabase struct {
	ExecHook   func(string, ...interface{}) (sql.Result, error)
	GetHook    func(interface{}, string, ...interface{}) error
	SelectHook func(interface{}, string, ...interface{}) error

	ExecCalls   []*DatabaseExecInvocation
	GetCalls    []*DatabaseGetInvocation
	SelectCalls []*DatabaseSelectInvocation
}

// NewFakeDatabaseDefaultPanic returns an instance of FakeDatabase with all hooks configured to panic
func NewFakeDatabaseDefaultPanic() *FakeDatabase {
	return &FakeDatabase{
		ExecHook: func(string, ...interface{}) (ident1 sql.Result, ident2 error) {
			panic("Unexpected call to Database.Exec")
		},
		GetHook: func(interface{}, string, ...interface{}) (ident1 error) {
			panic("Unexpected call to Database.Get")
		},
		SelectHook: func(interface{}, string, ...interface{}) (ident1 error) {
			panic("Unexpected call to Database.Select")
		},
	}
}

// NewFakeDatabaseDefaultFatal returns an instance of FakeDatabase with all hooks configured to call t.Fatal
func NewFakeDatabaseDefaultFatal(t_sym1 DatabaseTestingT) *FakeDatabase {
	return &FakeDatabase{
		ExecHook: func(string, ...interface{}) (ident1 sql.Result, ident2 error) {
			t_sym1.Fatal("Unexpected call to Database.Exec")
			return
		},
		GetHook: func(interface{}, string, ...interface{}) (ident1 error) {
			t_sym1.Fatal("Unexpected call to Database.Get")
			return
		},
		SelectHook: func(interface{}, string, ...interface{}) (ident1 error) {
			t_sym1.Fatal("Unexpected call to Database.Select")
			return
		},
	}
}

// NewFakeDatabaseDefaultError returns an instance of FakeDatabase with all hooks configured to call t.Error
func NewFakeDatabaseDefaultError(t_sym2 DatabaseTestingT) *FakeDatabase {
	return &FakeDatabase{
		ExecHook: func(string, ...interface{}) (ident1 sql.Result, ident2 error) {
			t_sym2.Error("Unexpected call to Database.Exec")
			return
		},
		GetHook: func(interface{}, string, ...interface{}) (ident1 error) {
			t_sym2.Error("Unexpected call to Database.Get")
			return
		},
		SelectHook: func(interface{}, string, ...interface{}) (ident1 error) {
			t_sym2.Error("Unexpected call to Database.Select")
			return
		},
	}
}

func (f *FakeDatabase) Reset() {
	f.ExecCalls = []*DatabaseExecInvocation{}
	f.GetCalls = []*DatabaseGetInvocation{}
	f.SelectCalls = []*DatabaseSelectInvocation{}
}

func (f_sym3 *FakeDatabase) Exec(query string, args ...interface{}) (ident1 sql.Result, ident2 error) {
	if f_sym3.ExecHook == nil {
		panic("Database.Exec() called but FakeDatabase.ExecHook is nil")
	}

	invocation_sym3 := new(DatabaseExecInvocation)
	f_sym3.ExecCalls = append(f_sym3.ExecCalls, invocation_sym3)

	invocation_sym3.Parameters.Query = query
	invocation_sym3.Parameters.Args = args

	ident1, ident2 = f_sym3.ExecHook(query, args...)

	invocation_sym3.Results.Ident1 = ident1
	invocation_sym3.Results.Ident2 = ident2

	return
}

// SetExecStub configures Database.Exec to always return the given values
func (f_sym4 *FakeDatabase) SetExecStub(ident1 sql.Result, ident2 error) {
	f_sym4.ExecHook = func(string, ...interface{}) (sql.Result, error) {
		return ident1, ident2
	}
}

// SetExecInvocation configures Database.Exec to return the given results when called with the given parameters
// If no match is found for an invocation the result(s) of the fallback function are returned
func (f_sym5 *FakeDatabase) SetExecInvocation(calls_sym5 []*DatabaseExecInvocation, fallback_sym5 func() (sql.Result, error)) {
	f_sym5.ExecHook = func(query string, args ...interface{}) (ident1 sql.Result, ident2 error) {
		for _, call_sym5 := range calls_sym5 {
			if reflect.DeepEqual(call_sym5.Parameters.Query, query) && reflect.DeepEqual(call_sym5.Parameters.Args, args) {
				ident1 = call_sym5.Results.Ident1
				ident2 = call_sym5.Results.Ident2

				return
			}
		}

		return fallback_sym5()
	}
}

// ExecCalled returns true if FakeDatabase.Exec was called
func (f *FakeDatabase) ExecCalled() bool {
	return len(f.ExecCalls) != 0
}

// AssertExecCalled calls t.Error if FakeDatabase.Exec was not called
func (f *FakeDatabase) AssertExecCalled(t DatabaseTestingT) {
	t.Helper()
	if len(f.ExecCalls) == 0 {
		t.Error("FakeDatabase.Exec not called, expected at least one")
	}
}

// ExecNotCalled returns true if FakeDatabase.Exec was not called
func (f *FakeDatabase) ExecNotCalled() bool {
	return len(f.ExecCalls) == 0
}

// AssertExecNotCalled calls t.Error if FakeDatabase.Exec was called
func (f *FakeDatabase) AssertExecNotCalled(t DatabaseTestingT) {
	t.Helper()
	if len(f.ExecCalls) != 0 {
		t.Error("FakeDatabase.Exec called, expected none")
	}
}

// ExecCalledOnce returns true if FakeDatabase.Exec was called exactly once
func (f *FakeDatabase) ExecCalledOnce() bool {
	return len(f.ExecCalls) == 1
}

// AssertExecCalledOnce calls t.Error if FakeDatabase.Exec was not called exactly once
func (f *FakeDatabase) AssertExecCalledOnce(t DatabaseTestingT) {
	t.Helper()
	if len(f.ExecCalls) != 1 {
		t.Errorf("FakeDatabase.Exec called %d times, expected 1", len(f.ExecCalls))
	}
}

// ExecCalledN returns true if FakeDatabase.Exec was called at least n times
func (f *FakeDatabase) ExecCalledN(n int) bool {
	return len(f.ExecCalls) >= n
}

// AssertExecCalledN calls t.Error if FakeDatabase.Exec was called less than n times
func (f *FakeDatabase) AssertExecCalledN(t DatabaseTestingT, n int) {
	t.Helper()
	if len(f.ExecCalls) < n {
		t.Errorf("FakeDatabase.Exec called %d times, expected >= %d", len(f.ExecCalls), n)
	}
}

// ExecCalledWith returns true if FakeDatabase.Exec was called with the given values
func (f_sym6 *FakeDatabase) ExecCalledWith(query string, args ...interface{}) bool {
	for _, call_sym6 := range f_sym6.ExecCalls {
		if reflect.DeepEqual(call_sym6.Parameters.Query, query) && reflect.DeepEqual(call_sym6.Parameters.Args, args) {
			return true
		}
	}

	return false
}

// AssertExecCalledWith calls t.Error if FakeDatabase.Exec was not called with the given values
func (f_sym7 *FakeDatabase) AssertExecCalledWith(t DatabaseTestingT, query string, args ...interface{}) {
	t.Helper()
	var found_sym7 bool
	for _, call_sym7 := range f_sym7.ExecCalls {
		if reflect.DeepEqual(call_sym7.Parameters.Query, query) && reflect.DeepEqual(call_sym7.Parameters.Args, args) {
			found_sym7 = true
			break
		}
	}

	if !found_sym7 {
		t.Error("FakeDatabase.Exec not called with expected parameters")
	}
}

// ExecCalledOnceWith returns true if FakeDatabase.Exec was called exactly once with the given values
func (f_sym8 *FakeDatabase) ExecCalledOnceWith(query string, args ...interface{}) bool {
	var count_sym8 int
	for _, call_sym8 := range f_sym8.ExecCalls {
		if reflect.DeepEqual(call_sym8.Parameters.Query, query) && reflect.DeepEqual(call_sym8.Parameters.Args, args) {
			count_sym8++
		}
	}

	return count_sym8 == 1
}

// AssertExecCalledOnceWith calls t.Error if FakeDatabase.Exec was not called exactly once with the given values
func (f_sym9 *FakeDatabase) AssertExecCalledOnceWith(t DatabaseTestingT, query string, args ...interface{}) {
	t.Helper()
	var count_sym9 int
	for _, call_sym9 := range f_sym9.ExecCalls {
		if reflect.DeepEqual(call_sym9.Parameters.Query, query) && reflect.DeepEqual(call_sym9.Parameters.Args, args) {
			count_sym9++
		}
	}

	if count_sym9 != 1 {
		t.Errorf("FakeDatabase.Exec called %d times with expected parameters, expected one", count_sym9)
	}
}

// ExecResultsForCall returns the result values for the first call to FakeDatabase.Exec with the given values
func (f_sym10 *FakeDatabase) ExecResultsForCall(query string, args ...interface{}) (ident1 sql.Result, ident2 error, found_sym10 bool) {
	for _, call_sym10 := range f_sym10.ExecCalls {
		if reflect.DeepEqual(call_sym10.Parameters.Query, query) && reflect.DeepEqual(call_sym10.Parameters.Args, args) {
			ident1 = call_sym10.Results.Ident1
			ident2 = call_sym10.Results.Ident2
			found_sym10 = true
			break
		}
	}

	return
}

func (f_sym11 *FakeDatabase) Get(dest interface{}, query string, args ...interface{}) (ident1 error) {
	if f_sym11.GetHook == nil {
		panic("Database.Get() called but FakeDatabase.GetHook is nil")
	}

	invocation_sym11 := new(DatabaseGetInvocation)
	f_sym11.GetCalls = append(f_sym11.GetCalls, invocation_sym11)

	invocation_sym11.Parameters.Dest = dest
	invocation_sym11.Parameters.Query = query
	invocation_sym11.Parameters.Args = args

	ident1 = f_sym11.GetHook(dest, query, args...)

	invocation_sym11.Results.Ident1 = ident1

	return
}

// SetGetStub configures Database.Get to always return the given values
func (f_sym12 *FakeDatabase) SetGetStub(ident1 error) {
	f_sym12.GetHook = func(interface{}, string, ...interface{}) error {
		return ident1
	}
}

// SetGetInvocation configures Database.Get to return the given results when called with the given parameters
// If no match is found for an invocation the result(s) of the fallback function are returned
func (f_sym13 *FakeDatabase) SetGetInvocation(calls_sym13 []*DatabaseGetInvocation, fallback_sym13 func() error) {
	f_sym13.GetHook = func(dest interface{}, query string, args ...interface{}) (ident1 error) {
		for _, call_sym13 := range calls_sym13 {
			if reflect.DeepEqual(call_sym13.Parameters.Dest, dest) && reflect.DeepEqual(call_sym13.Parameters.Query, query) && reflect.DeepEqual(call_sym13.Parameters.Args, args) {
				ident1 = call_sym13.Results.Ident1

				return
			}
		}

		return fallback_sym13()
	}
}

// GetCalled returns true if FakeDatabase.Get was called
func (f *FakeDatabase) GetCalled() bool {
	return len(f.GetCalls) != 0
}

// AssertGetCalled calls t.Error if FakeDatabase.Get was not called
func (f *FakeDatabase) AssertGetCalled(t DatabaseTestingT) {
	t.Helper()
	if len(f.GetCalls) == 0 {
		t.Error("FakeDatabase.Get not called, expected at least one")
	}
}

// GetNotCalled returns true if FakeDatabase.Get was not called
func (f *FakeDatabase) GetNotCalled() bool {
	return len(f.GetCalls) == 0
}

// AssertGetNotCalled calls t.Error if FakeDatabase.Get was called
func (f *FakeDatabase) AssertGetNotCalled(t DatabaseTestingT) {
	t.Helper()
	if len(f.GetCalls) != 0 {
		t.Error("FakeDatabase.Get called, expected none")
	}
}

// GetCalledOnce returns true if FakeDatabase.Get was called exactly once
func (f *FakeDatabase) GetCalledOnce() bool {
	return len(f.GetCalls) == 1
}

// AssertGetCalledOnce calls t.Error if FakeDatabase.Get was not called exactly once
func (f *FakeDatabase) AssertGetCalledOnce(t DatabaseTestingT) {
	t.Helper()
	if len(f.GetCalls) != 1 {
		t.Errorf("FakeDatabase.Get called %d times, expected 1", len(f.GetCalls))
	}
}

// GetCalledN returns true if FakeDatabase.Get was called at least n times
func (f *FakeDatabase) GetCalledN(n int) bool {
	return len(f.GetCalls) >= n
}

// AssertGetCalledN calls t.Error if FakeDatabase.Get was called less than n times
func (f *FakeDatabase) AssertGetCalledN(t DatabaseTestingT, n int) {
	t.Helper()
	if len(f.GetCalls) < n {
		t.Errorf("FakeDatabase.Get called %d times, expected >= %d", len(f.GetCalls), n)
	}
}

// GetCalledWith returns true if FakeDatabase.Get was called with the given values
func (f_sym14 *FakeDatabase) GetCalledWith(dest interface{}, query string, args ...interface{}) bool {
	for _, call_sym14 := range f_sym14.GetCalls {
		if reflect.DeepEqual(call_sym14.Parameters.Dest, dest) && reflect.DeepEqual(call_sym14.Parameters.Query, query) && reflect.DeepEqual(call_sym14.Parameters.Args, args) {
			return true
		}
	}

	return false
}

// AssertGetCalledWith calls t.Error if FakeDatabase.Get was not called with the given values
func (f_sym15 *FakeDatabase) AssertGetCalledWith(t DatabaseTestingT, dest interface{}, query string, args ...interface{}) {
	t.Helper()
	var found_sym15 bool
	for _, call_sym15 := range f_sym15.GetCalls {
		if reflect.DeepEqual(call_sym15.Parameters.Dest, dest) && reflect.DeepEqual(call_sym15.Parameters.Query, query) && reflect.DeepEqual(call_sym15.Parameters.Args, args) {
			found_sym15 = true
			break
		}
	}

	if !found_sym15 {
		t.Error("FakeDatabase.Get not called with expected parameters")
	}
}

// GetCalledOnceWith returns true if FakeDatabase.Get was called exactly once with the given values
func (f_sym16 *FakeDatabase) GetCalledOnceWith(dest interface{}, query string, args ...interface{}) bool {
	var count_sym16 int
	for _, call_sym16 := range f_sym16.GetCalls {
		if reflect.DeepEqual(call_sym16.Parameters.Dest, dest) && reflect.DeepEqual(call_sym16.Parameters.Query, query) && reflect.DeepEqual(call_sym16.Parameters.Args, args) {
			count_sym16++
		}
	}

	return count_sym16 == 1
}

// AssertGetCalledOnceWith calls t.Error if FakeDatabase.Get was not called exactly once with the given values
func (f_sym17 *FakeDatabase) AssertGetCalledOnceWith(t DatabaseTestingT, dest interface{}, query string, args ...interface{}) {
	t.Helper()
	var count_sym17 int
	for _, call_sym17 := range f_sym17.GetCalls {
		if reflect.DeepEqual(call_sym17.Parameters.Dest, dest) && reflect.DeepEqual(call_sym17.Parameters.Query, query) && reflect.DeepEqual(call_sym17.Parameters.Args, args) {
			count_sym17++
		}
	}

	if count_sym17 != 1 {
		t.Errorf("FakeDatabase.Get called %d times with expected parameters, expected one", count_sym17)
	}
}

// GetResultsForCall returns the result values for the first call to FakeDatabase.Get with the given values
func (f_sym18 *FakeDatabase) GetResultsForCall(dest interface{}, query string, args ...interface{}) (ident1 error, found_sym18 bool) {
	for _, call_sym18 := range f_sym18.GetCalls {
		if reflect.DeepEqual(call_sym18.Parameters.Dest, dest) && reflect.DeepEqual(call_sym18.Parameters.Query, query) && reflect.DeepEqual(call_sym18.Parameters.Args, args) {
			ident1 = call_sym18.Results.Ident1
			found_sym18 = true
			break
		}
	}

	return
}

func (f_sym19 *FakeDatabase) Select(dest interface{}, query string, args ...interface{}) (ident1 error) {
	if f_sym19.SelectHook == nil {
		panic("Database.Select() called but FakeDatabase.SelectHook is nil")
	}

	invocation_sym19 := new(DatabaseSelectInvocation)
	f_sym19.SelectCalls = append(f_sym19.SelectCalls, invocation_sym19)

	invocation_sym19.Parameters.Dest = dest
	invocation_sym19.Parameters.Query = query
	invocation_sym19.Parameters.Args = args

	ident1 = f_sym19.SelectHook(dest, query, args...)

	invocation_sym19.Results.Ident1 = ident1

	return
}

// SetSelectStub configures Database.Select to always return the given values
func (f_sym20 *FakeDatabase) SetSelectStub(ident1 error) {
	f_sym20.SelectHook = func(interface{}, string, ...interface{}) error {
		return ident1
	}
}

// SetSelectInvocation configures Database.Select to return the given results when called with the given parameters
// If no match is found for an invocation the result(s) of the fallback function are returned
func (f_sym21 *FakeDatabase) SetSelectInvocation(calls_sym21 []*DatabaseSelectInvocation, fallback_sym21 func() error) {
	f_sym21.SelectHook = func(dest interface{}, query string, args ...interface{}) (ident1 error) {
		for _, call_sym21 := range calls_sym21 {
			if reflect.DeepEqual(call_sym21.Parameters.Dest, dest) && reflect.DeepEqual(call_sym21.Parameters.Query, query) && reflect.DeepEqual(call_sym21.Parameters.Args, args) {
				ident1 = call_sym21.Results.Ident1

				return
			}
		}

		return fallback_sym21()
	}
}

// SelectCalled returns true if FakeDatabase.Select was called
func (f *FakeDatabase) SelectCalled() bool {
	return len(f.SelectCalls) != 0
}

// AssertSelectCalled calls t.Error if FakeDatabase.Select was not called
func (f *FakeDatabase) AssertSelectCalled(t DatabaseTestingT) {
	t.Helper()
	if len(f.SelectCalls) == 0 {
		t.Error("FakeDatabase.Select not called, expected at least one")
	}
}

// SelectNotCalled returns true if FakeDatabase.Select was not called
func (f *FakeDatabase) SelectNotCalled() bool {
	return len(f.SelectCalls) == 0
}

// AssertSelectNotCalled calls t.Error if FakeDatabase.Select was called
func (f *FakeDatabase) AssertSelectNotCalled(t DatabaseTestingT) {
	t.Helper()
	if len(f.SelectCalls) != 0 {
		t.Error("FakeDatabase.Select called, expected none")
	}
}

// SelectCalledOnce returns true if FakeDatabase.Select was called exactly once
func (f *FakeDatabase) SelectCalledOnce() bool {
	return len(f.SelectCalls) == 1
}

// AssertSelectCalledOnce calls t.Error if FakeDatabase.Select was not called exactly once
func (f *FakeDatabase) AssertSelectCalledOnce(t DatabaseTestingT) {
	t.Helper()
	if len(f.SelectCalls) != 1 {
		t.Errorf("FakeDatabase.Select called %d times, expected 1", len(f.SelectCalls))
	}
}

// SelectCalledN returns true if FakeDatabase.Select was called at least n times
func (f *FakeDatabase) SelectCalledN(n int) bool {
	return len(f.SelectCalls) >= n
}

// AssertSelectCalledN calls t.Error if FakeDatabase.Select was called less than n times
func (f *FakeDatabase) AssertSelectCalledN(t DatabaseTestingT, n int) {
	t.Helper()
	if len(f.SelectCalls) < n {
		t.Errorf("FakeDatabase.Select called %d times, expected >= %d", len(f.SelectCalls), n)
	}
}

// SelectCalledWith returns true if FakeDatabase.Select was called with the given values
func (f_sym22 *FakeDatabase) SelectCalledWith(dest interface{}, query string, args ...interface{}) bool {
	for _, call_sym22 := range f_sym22.SelectCalls {
		if reflect.DeepEqual(call_sym22.Parameters.Dest, dest) && reflect.DeepEqual(call_sym22.Parameters.Query, query) && reflect.DeepEqual(call_sym22.Parameters.Args, args) {
			return true
		}
	}

	return false
}

// AssertSelectCalledWith calls t.Error if FakeDatabase.Select was not called with the given values
func (f_sym23 *FakeDatabase) AssertSelectCalledWith(t DatabaseTestingT, dest interface{}, query string, args ...interface{}) {
	t.Helper()
	var found_sym23 bool
	for _, call_sym23 := range f_sym23.SelectCalls {
		if reflect.DeepEqual(call_sym23.Parameters.Dest, dest) && reflect.DeepEqual(call_sym23.Parameters.Query, query) && reflect.DeepEqual(call_sym23.Parameters.Args, args) {
			found_sym23 = true
			break
		}
	}

	if !found_sym23 {
		t.Error("FakeDatabase.Select not called with expected parameters")
	}
}

// SelectCalledOnceWith returns true if FakeDatabase.Select was called exactly once with the given values
func (f_sym24 *FakeDatabase) SelectCalledOnceWith(dest interface{}, query string, args ...interface{}) bool {
	var count_sym24 int
	for _, call_sym24 := range f_sym24.SelectCalls {
		if reflect.DeepEqual(call_sym24.Parameters.Dest, dest) && reflect.DeepEqual(call_sym24.Parameters.Query, query) && reflect.DeepEqual(call_sym24.Parameters.Args, args) {
			count_sym24++
		}
	}

	return count_sym24 == 1
}

// AssertSelectCalledOnceWith calls t.Error if FakeDatabase.Select was not called exactly once with the given values
func (f_sym25 *FakeDatabase) AssertSelectCalledOnceWith(t DatabaseTestingT, dest interface{}, query string, args ...interface{}) {
	t.Helper()
	var count_sym25 int
	for _, call_sym25 := range f_sym25.SelectCalls {
		if reflect.DeepEqual(call_sym25.Parameters.Dest, dest) && reflect.DeepEqual(call_sym25.Parameters.Query, query) && reflect.DeepEqual(call_sym25.Parameters.Args, args) {
			count_sym25++
		}
	}

	if count_sym25 != 1 {
		t.Errorf("FakeDatabase.Select called %d times with expected parameters, expected one", count_sym25)
	}
}

// SelectResultsForCall returns the result values for the first call to FakeDatabase.Select with the given values
func (f_sym26 *FakeDatabase) SelectResultsForCall(dest interface{}, query string, args ...interface{}) (ident1 error, found_sym26 bool) {
	for _, call_sym26 := range f_sym26.SelectCalls {
		if reflect.DeepEqual(call_sym26.Parameters.Dest, dest) && reflect.DeepEqual(call_sym26.Parameters.Query, query) && reflect.DeepEqual(call_sym26.Parameters.Args, args) {
			ident1 = call_sym26.Results.Ident1
			found_sym26 = true
			break
		}
	}

	return
}

// SQLResultLastInsertIdInvocation represents a single call of FakeSQLResult.LastInsertId
type SQLResultLastInsertIdInvocation struct {
	Results struct {
		Ident1 int64
		Ident2 error
	}
}

// SQLResultRowsAffectedInvocation represents a single call of FakeSQLResult.RowsAffected
type SQLResultRowsAffectedInvocation struct {
	Results struct {
		Ident1 int64
		Ident2 error
	}
}

// SQLResultTestingT represents the methods of "testing".T used by charlatan Fakes.  It avoids importing the testing package.
type SQLResultTestingT interface {
	Error(...interface{})
	Errorf(string, ...interface{})
	Fatal(...interface{})
	Helper()
}

/*
FakeSQLResult is a mock implementation of SQLResult for testing.
Use it in your tests as in this example:

	package example

	func TestWithSQLResult(t *testing.T) {
		f := &api.FakeSQLResult{
			LastInsertIdHook: func() (ident1 int64, ident2 error) {
				// ensure parameters meet expections, signal errors using t, etc
				return
			},
		}

		// test code goes here ...

		// assert state of FakeLastInsertId ...
		f.AssertLastInsertIdCalledOnce(t)
	}

Create anonymous function implementations for only those interface methods that
should be called in the code under test.  This will force a panic if any
unexpected calls are made to FakeLastInsertId.
*/
type FakeSQLResult struct {
	LastInsertIdHook func() (int64, error)
	RowsAffectedHook func() (int64, error)

	LastInsertIdCalls []*SQLResultLastInsertIdInvocation
	RowsAffectedCalls []*SQLResultRowsAffectedInvocation
}

// NewFakeSQLResultDefaultPanic returns an instance of FakeSQLResult with all hooks configured to panic
func NewFakeSQLResultDefaultPanic() *FakeSQLResult {
	return &FakeSQLResult{
		LastInsertIdHook: func() (ident1 int64, ident2 error) {
			panic("Unexpected call to SQLResult.LastInsertId")
		},
		RowsAffectedHook: func() (ident1 int64, ident2 error) {
			panic("Unexpected call to SQLResult.RowsAffected")
		},
	}
}

// NewFakeSQLResultDefaultFatal returns an instance of FakeSQLResult with all hooks configured to call t.Fatal
func NewFakeSQLResultDefaultFatal(t_sym27 SQLResultTestingT) *FakeSQLResult {
	return &FakeSQLResult{
		LastInsertIdHook: func() (ident1 int64, ident2 error) {
			t_sym27.Fatal("Unexpected call to SQLResult.LastInsertId")
			return
		},
		RowsAffectedHook: func() (ident1 int64, ident2 error) {
			t_sym27.Fatal("Unexpected call to SQLResult.RowsAffected")
			return
		},
	}
}

// NewFakeSQLResultDefaultError returns an instance of FakeSQLResult with all hooks configured to call t.Error
func NewFakeSQLResultDefaultError(t_sym28 SQLResultTestingT) *FakeSQLResult {
	return &FakeSQLResult{
		LastInsertIdHook: func() (ident1 int64, ident2 error) {
			t_sym28.Error("Unexpected call to SQLResult.LastInsertId")
			return
		},
		RowsAffectedHook: func() (ident1 int64, ident2 error) {
			t_sym28.Error("Unexpected call to SQLResult.RowsAffected")
			return
		},
	}
}

func (f *FakeSQLResult) Reset() {
	f.LastInsertIdCalls = []*SQLResultLastInsertIdInvocation{}
	f.RowsAffectedCalls = []*SQLResultRowsAffectedInvocation{}
}

func (f_sym29 *FakeSQLResult) LastInsertId() (ident1 int64, ident2 error) {
	if f_sym29.LastInsertIdHook == nil {
		panic("SQLResult.LastInsertId() called but FakeSQLResult.LastInsertIdHook is nil")
	}

	invocation_sym29 := new(SQLResultLastInsertIdInvocation)
	f_sym29.LastInsertIdCalls = append(f_sym29.LastInsertIdCalls, invocation_sym29)

	ident1, ident2 = f_sym29.LastInsertIdHook()

	invocation_sym29.Results.Ident1 = ident1
	invocation_sym29.Results.Ident2 = ident2

	return
}

// SetLastInsertIdStub configures SQLResult.LastInsertId to always return the given values
func (f_sym30 *FakeSQLResult) SetLastInsertIdStub(ident1 int64, ident2 error) {
	f_sym30.LastInsertIdHook = func() (int64, error) {
		return ident1, ident2
	}
}

// LastInsertIdCalled returns true if FakeSQLResult.LastInsertId was called
func (f *FakeSQLResult) LastInsertIdCalled() bool {
	return len(f.LastInsertIdCalls) != 0
}

// AssertLastInsertIdCalled calls t.Error if FakeSQLResult.LastInsertId was not called
func (f *FakeSQLResult) AssertLastInsertIdCalled(t SQLResultTestingT) {
	t.Helper()
	if len(f.LastInsertIdCalls) == 0 {
		t.Error("FakeSQLResult.LastInsertId not called, expected at least one")
	}
}

// LastInsertIdNotCalled returns true if FakeSQLResult.LastInsertId was not called
func (f *FakeSQLResult) LastInsertIdNotCalled() bool {
	return len(f.LastInsertIdCalls) == 0
}

// AssertLastInsertIdNotCalled calls t.Error if FakeSQLResult.LastInsertId was called
func (f *FakeSQLResult) AssertLastInsertIdNotCalled(t SQLResultTestingT) {
	t.Helper()
	if len(f.LastInsertIdCalls) != 0 {
		t.Error("FakeSQLResult.LastInsertId called, expected none")
	}
}

// LastInsertIdCalledOnce returns true if FakeSQLResult.LastInsertId was called exactly once
func (f *FakeSQLResult) LastInsertIdCalledOnce() bool {
	return len(f.LastInsertIdCalls) == 1
}

// AssertLastInsertIdCalledOnce calls t.Error if FakeSQLResult.LastInsertId was not called exactly once
func (f *FakeSQLResult) AssertLastInsertIdCalledOnce(t SQLResultTestingT) {
	t.Helper()
	if len(f.LastInsertIdCalls) != 1 {
		t.Errorf("FakeSQLResult.LastInsertId called %d times, expected 1", len(f.LastInsertIdCalls))
	}
}

// LastInsertIdCalledN returns true if FakeSQLResult.LastInsertId was called at least n times
func (f *FakeSQLResult) LastInsertIdCalledN(n int) bool {
	return len(f.LastInsertIdCalls) >= n
}

// AssertLastInsertIdCalledN calls t.Error if FakeSQLResult.LastInsertId was called less than n times
func (f *FakeSQLResult) AssertLastInsertIdCalledN(t SQLResultTestingT, n int) {
	t.Helper()
	if len(f.LastInsertIdCalls) < n {
		t.Errorf("FakeSQLResult.LastInsertId called %d times, expected >= %d", len(f.LastInsertIdCalls), n)
	}
}

func (f_sym31 *FakeSQLResult) RowsAffected() (ident1 int64, ident2 error) {
	if f_sym31.RowsAffectedHook == nil {
		panic("SQLResult.RowsAffected() called but FakeSQLResult.RowsAffectedHook is nil")
	}

	invocation_sym31 := new(SQLResultRowsAffectedInvocation)
	f_sym31.RowsAffectedCalls = append(f_sym31.RowsAffectedCalls, invocation_sym31)

	ident1, ident2 = f_sym31.RowsAffectedHook()

	invocation_sym31.Results.Ident1 = ident1
	invocation_sym31.Results.Ident2 = ident2

	return
}

// SetRowsAffectedStub configures SQLResult.RowsAffected to always return the given values
func (f_sym32 *FakeSQLResult) SetRowsAffectedStub(ident1 int64, ident2 error) {
	f_sym32.RowsAffectedHook = func() (int64, error) {
		return ident1, ident2
	}
}

// RowsAffectedCalled returns true if FakeSQLResult.RowsAffected was called
func (f *FakeSQLResult) RowsAffectedCalled() bool {
	return len(f.RowsAffectedCalls) != 0
}

// AssertRowsAffectedCalled calls t.Error if FakeSQLResult.RowsAffected was not called
func (f *FakeSQLResult) AssertRowsAffectedCalled(t SQLResultTestingT) {
	t.Helper()
	if len(f.RowsAffectedCalls) == 0 {
		t.Error("FakeSQLResult.RowsAffected not called, expected at least one")
	}
}

// RowsAffectedNotCalled returns true if FakeSQLResult.RowsAffected was not called
func (f *FakeSQLResult) RowsAffectedNotCalled() bool {
	return len(f.RowsAffectedCalls) == 0
}

// AssertRowsAffectedNotCalled calls t.Error if FakeSQLResult.RowsAffected was called
func (f *FakeSQLResult) AssertRowsAffectedNotCalled(t SQLResultTestingT) {
	t.Helper()
	if len(f.RowsAffectedCalls) != 0 {
		t.Error("FakeSQLResult.RowsAffected called, expected none")
	}
}

// RowsAffectedCalledOnce returns true if FakeSQLResult.RowsAffected was called exactly once
func (f *FakeSQLResult) RowsAffectedCalledOnce() bool {
	return len(f.RowsAffectedCalls) == 1
}

// AssertRowsAffectedCalledOnce calls t.Error if FakeSQLResult.RowsAffected was not called exactly once
func (f *FakeSQLResult) AssertRowsAffectedCalledOnce(t SQLResultTestingT) {
	t.Helper()
	if len(f.RowsAffectedCalls) != 1 {
		t.Errorf("FakeSQLResult.RowsAffected called %d times, expected 1", len(f.RowsAffectedCalls))
	}
}

// RowsAffectedCalledN returns true if FakeSQLResult.RowsAffected was called at least n times
func (f *FakeSQLResult) RowsAffectedCalledN(n int) bool {
	return len(f.RowsAffectedCalls) >= n
}

// AssertRowsAffectedCalledN calls t.Error if FakeSQLResult.RowsAffected was called less than n times
func (f *FakeSQLResult) AssertRowsAffectedCalledN(t SQLResultTestingT, n int) {
	t.Helper()
	if len(f.RowsAffectedCalls) < n {
		t.Errorf("FakeSQLResult.RowsAffected called %d times, expected >= %d", len(f.RowsAffectedCalls), n)
	}
}
